<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.20">
<meta name="author" content="Gabriel Souto Lozano Barbosa - gabriel.barbosa.082@ufrn.edu.br">
<title>Processamento Digital de Imagens</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.square{list-style-type:square}
ul.circle ul:not([class]),ul.disc ul:not([class]),ul.square ul:not([class]){list-style:inherit}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:first-child,.sidebarblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child,.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,td.hdlist1,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Processamento Digital de Imagens</h1>
<div class="details">
<span id="author" class="author">Gabriel Souto Lozano Barbosa - gabriel.barbosa.082@ufrn.edu.br</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_1_manipulando_pixels_em_uma_imagem">1. Manipulando pixels em uma imagem.</a>
<ul class="sectlevel2">
<li><a href="#_1_1_filtro_negativo_regions_cpp">1.1. Filtro Negativo (regions.cpp)</a></li>
<li><a href="#_1_2_troca_de_regiões">1.2 Troca de regiões</a></li>
</ul>
</li>
<li><a href="#_2_serialização_via_filestore">2. Serialização via FileStore</a>
<ul class="sectlevel2">
<li><a href="#_2_1_filestore">2.1. FileStore</a></li>
</ul>
</li>
<li><a href="#_3_decomposição_de_imagens_em_planos_de_bits">3. Decomposição de imagens em planos de bits</a>
<ul class="sectlevel2">
<li><a href="#_3_1_esteganografia_em_imagens_digitais">3.1 Esteganografia em imagens digitais</a></li>
</ul>
</li>
<li><a href="#_4_preenchendo_regiões">4. Preenchendo regiões</a>
<ul class="sectlevel2">
<li><a href="#_4_1_floodfill">4.1 FloodFill</a></li>
</ul>
</li>
<li><a href="#_5_manipulação_de_histogramas">5. Manipulação de histogramas</a>
<ul class="sectlevel2">
<li><a href="#_5_1_histograma">5.1 Histograma</a></li>
</ul>
</li>
<li><a href="#_6_filtragem_no_domínio_espacial_i">6. Filtragem no domínio espacial I.</a>
<ul class="sectlevel2">
<li><a href="#_6_1_laplaciano_do_gaussiano">6.1 Laplaciano do Gaussiano.</a></li>
<li><a href="#_6_2_tiltshift">6.2 TiltShift</a></li>
</ul>
</li>
<li><a href="#_7_a_tranformada_discreta_de_fourier">7. A Tranformada Discreta de Fourier</a>
<ul class="sectlevel2">
<li><a href="#_7_1">7.1</a></li>
</ul>
</li>
<li><a href="#_8_filtragem_no_domínio_da_frequência">8. Filtragem no Domínio da Frequência</a>
<ul class="sectlevel2">
<li><a href="#_8_1_filtro_homomórfico">8.1 Filtro Homomórfico</a></li>
</ul>
</li>
<li><a href="#_9_detecção_de_bordas_com_o_algoritmo_de_canny">9. Detecção de bordas com o algoritmo de Canny</a>
<ul class="sectlevel2">
<li><a href="#_9_1_canny_pontilhismo">9.1 Canny &amp; Pontilhismo</a></li>
</ul>
</li>
<li><a href="#_10_quantização_vetorial_com_k_means">10. Quantização vetorial com k-means</a>
<ul class="sectlevel2">
<li><a href="#_10_1_k_means">10.1 K-means</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_1_manipulando_pixels_em_uma_imagem">1. Manipulando pixels em uma imagem.</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A manipulação de pixels em uma imagem refere-se ao processo de alterar as propriedades dos pixels
individuais que compõe a imagem, como, por exemplo, modificar o valor da cor do pixel, alterar a
sua posição na imagem, aplicar filtros ou efeitos especiais, entre outros. Desta forma, é possível
realizar uma infinidade de tarefas, como redimensionar uma imagem, remover objetos indesejados,
corrigir imperfeições, aplicar efeitos artísticos, criar animações, entre outras aplicações criativas
e práticas.</p>
</div>
<div class="sect2">
<h3 id="_1_1_filtro_negativo_regions_cpp">1.1. Filtro Negativo (regions.cpp)</h3>
<div class="paragraph">
<p>Um filtro negativo em uma imagem é uma técnica de manipulação de pixels que inverte as cores da imagem
original. Nesse filtro, cada pixel da imagem é transformado em seu complemento, resultando em uma imagem
com cores invertidas.
Além de criar um efeito estético interessante, o filtro negativo também pode ser útil em certas aplicações,
como melhorar a visualização de detalhes em imagens com alto contraste ou realçar certos elementos.
No entanto, é importante notar que a aplicação de um filtro negativo em uma imagem não é uma técnica que
preserva informações importantes da imagem original, mas sim uma transformação visual que pode ser usada para
efeitos artísticos ou estilísticos.</p>
</div>
<div class="sect3">
<h4 id="_1_1_1_código_resultado">1.1.1. Código &amp; Resultado.</h4>
<div class="paragraph">
<p>Implemente um programa regions.cpp. Esse programa deverá solicitar ao usuário as coordenadas de dois pontos
P1 e P2 localizados dentro dos limites do tamanho da imagem e exibir que lhe for fornecida. Entretanto, a
região definida pelo retângulo de vértices opostos definidos pelos pontos P1 e P2 será exibida com o negativo
da imagem na região correspondente.</p>
</div>
<div class="listingblock">
<div class="title">regions.cpp</div>
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;

using namespace cv;
using namespace std;

int main() {
	cout &lt;&lt; "INICIANDO..." &lt;&lt; endl;

	Mat image;
	int P1X, P1Y, P2X, P2Y;
	char diretorio[1000];

	cout &lt;&lt; "Digite a loc da imagem: " &lt;&lt; endl;
	cout &lt;&lt; "EX.: C:\\User\\Desktop\\&lt;nomedaimagem&gt;.png" &lt;&lt; endl;
	cin &gt;&gt; diretorio;

	auto imageO = imread(diretorio);
	image = imread(diretorio, IMREAD_GRAYSCALE);

	int rows = image.rows;
	int cols = image.cols;

	cout &lt;&lt; "Digite o ponto P1 da imagem" &lt;&lt; endl;
	cout &lt;&lt; "Entre Linha 0 e" &lt;&lt; " " &lt;&lt; (rows - 1) &lt;&lt; " " &lt;&lt; "e Coluna 0 e" &lt;&lt; " " &lt;&lt; (cols - 1) &lt;&lt; endl;
	cin &gt;&gt; P1X &gt;&gt; P1Y;
	cout &lt;&lt; "(" &lt;&lt; P1X &lt;&lt; "," &lt;&lt; P1Y &lt;&lt; ")" &lt;&lt; endl;
	cout &lt;&lt; "Digite 0 para cancelar e 1 para confirmar" &lt;&lt; endl;

	int confirmaP1;

	do {
		cin &gt;&gt; confirmaP1;
		if (confirmaP1 == 0) {
			cout &lt;&lt; "Digite o ponto P1 da imagem" &lt;&lt; endl;
			cout &lt;&lt; "Entre Linha 0 e" &lt;&lt; " " &lt;&lt; (rows - 1) &lt;&lt; " " &lt;&lt; "e Coluna 0 e" &lt;&lt; " " &lt;&lt; (cols - 1) &lt;&lt; endl;
			cin &gt;&gt; P1X &gt;&gt; P1Y;
			cout &lt;&lt; "(" &lt;&lt; P1X &lt;&lt; "," &lt;&lt; P1Y &lt;&lt; ")" &lt;&lt; endl;

			cout &lt;&lt; "Digite 0 para cancelar e 1 para confirmar" &lt;&lt; endl;
			cin &gt;&gt; confirmaP1;
		}

		if (confirmaP1 == 1 &amp;&amp; (P1X &lt; 0 || P1X &gt; rows)) {
			cout &lt;&lt; "Valor de X do ponto P1 localiza-se fora da imagem, digite novamente P1X: " &lt;&lt; endl;
			cin &gt;&gt; P1X;

			cout &lt;&lt; "(" &lt;&lt; P1X &lt;&lt; "," &lt;&lt; P1Y &lt;&lt; ")" &lt;&lt; endl;
			cout &lt;&lt; "Digite 0 para cancelar e 1 para confirmar" &lt;&lt; endl;
			cin &gt;&gt; confirmaP1;
		}

		if (confirmaP1 == 1 &amp;&amp; (P1Y&lt; 0 || P1Y &gt; cols)) {
			cout &lt;&lt; "Valor de Y do ponto P1 localiza-se fora da imagem, digite novamente P1Y: " &lt;&lt; endl;
			cin &gt;&gt; P1Y;

			cout &lt;&lt; "(" &lt;&lt; P1X &lt;&lt; "," &lt;&lt; P1Y &lt;&lt; ")" &lt;&lt; endl;
			cout &lt;&lt; "Digite 0 para cancelar e 1 para confirmar" &lt;&lt; endl;
			cin &gt;&gt; confirmaP1;
		}

	} while (confirmaP1 == 0);

	cout &lt;&lt; "Digite o ponto P2 da imagem" &lt;&lt; endl;
	cout &lt;&lt; "Entre Linha 0 e" &lt;&lt; " " &lt;&lt; (rows - 1) &lt;&lt; " " &lt;&lt; "e Coluna 0 e" &lt;&lt; " " &lt;&lt; (cols - 1) &lt;&lt; endl;
	cin &gt;&gt; P2X &gt;&gt; P2Y;
	cout &lt;&lt; "(" &lt;&lt; P2X &lt;&lt; "," &lt;&lt; P2Y &lt;&lt; ")" &lt;&lt; endl;
	cout &lt;&lt; "Digite 0 para cancelar e 1 para confirmar" &lt;&lt; endl;

	int confirmaP2;
	do {
		cin &gt;&gt; confirmaP2;
		if (confirmaP2 == 0) {
			cout &lt;&lt; "Digite o ponto P2 da imagem" &lt;&lt; endl;
			cout &lt;&lt; "Entre Linha 0 e" &lt;&lt; " " &lt;&lt; (rows - 1) &lt;&lt; " " &lt;&lt; "e Coluna 0 e" &lt;&lt; " " &lt;&lt; (cols - 1) &lt;&lt; endl;
			cin &gt;&gt; P2X &gt;&gt; P2Y;
			cout &lt;&lt; "(" &lt;&lt; P2X &lt;&lt; "," &lt;&lt; P2Y &lt;&lt; ")" &lt;&lt; endl;

			cout &lt;&lt; "Digite 0 para cancelar e 1 para confirmar" &lt;&lt; endl;
			cin &gt;&gt; confirmaP2;
		}

		if (confirmaP2 == 1 &amp;&amp; (P2X &lt; 0 || P2X &gt; rows || P2X &lt; P1X)) {
			cout &lt;&lt; "Valor de X do ponto P2 localiza-se fora da imagem ou eh menor que P1X, digite novamente P2X: " &lt;&lt; endl;
			cin &gt;&gt; P2X;

			cout &lt;&lt; "(" &lt;&lt; P2X &lt;&lt; "," &lt;&lt; P2Y &lt;&lt; ")" &lt;&lt; endl;
			cout &lt;&lt; "Digite 0 para cancelar e 1 para confirmar" &lt;&lt; endl;
			cin &gt;&gt; confirmaP2;
		}

		if (confirmaP2 == 1 &amp;&amp; (P2Y&lt; 0 || P2Y &gt; cols || P2Y &lt; P1Y)) {
			cout &lt;&lt; "Valor de Y do ponto P2 localiza-se fora da imagem ou eh menor que P1Y, digite novamente P2Y: " &lt;&lt; endl;
			cin &gt;&gt; P2Y;

			cout &lt;&lt; "(" &lt;&lt; P2X &lt;&lt; "," &lt;&lt; P2Y &lt;&lt; ")" &lt;&lt; endl;
			cout &lt;&lt; "Digite 0 para cancelar e 1 para confirmar" &lt;&lt; endl;
			cin &gt;&gt; confirmaP2;
		}
	} while (confirmaP2 == 0);

	if (!image.data) {
		cout &lt;&lt; "Imagem nao encontrada!" &lt;&lt; endl;
	}

	for (int i = P1X; i &lt; P2X; i++) {
		for (int j = P1Y; j &lt; P2Y; j++) {

			image.at&lt;uchar&gt;(i, j) = 255 - image.at&lt;uchar&gt;(i, j);

		}
	}

	imwrite("janelaNegativo.png", image);
	namedWindow("janelaOriginal", WINDOW_AUTOSIZE);
	imshow("janelaOriginal", imageO);
	namedWindow("janelaNegativo", WINDOW_AUTOSIZE);
	imshow("janelaNegativo", image);

	waitKey();

	return 0;

}</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="./imagem/biel.png" alt="biel" width="256" height="256">
</div>
<div class="title">Figure 1. Biel original</div>
</div>
<div class="imageblock">
<div class="content">
<img src="./imagem/janelaNegativo.png" alt="janelaNegativo" width="256" height="256">
</div>
<div class="title">Figure 2. Biel com filtro negativo</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_1_2_troca_de_regiões">1.2 Troca de regiões</h3>
<div class="paragraph">
<p>A transposição de quadrante envolve a troca desses quadrantes, de modo que as baixas frequências fiquem
no quadrante inferior direito e as altas frequências no quadrante superior esquerdo. Essa operação é
frequentemente realizada para fins de visualização ou processamento de imagens, uma vez que a transposição
pode melhorar a interpretação visual ou permitir a aplicação de determinadas técnicas de filtragem ou análise.
Após a transposição de quadrante, é possível realizar operações de filtragem ou análise no domínio da frequência
e, em seguida, reverter a imagem para o domínio espacial, se necessário.</p>
</div>
<div class="sect3">
<h4 id="_1_2_1_código_resultado">1.2.1 Código &amp; Resultado.</h4>
<div class="paragraph">
<p>Implemente um programa trocaregioes.cpp. Seu programa deverá trocar os quadrantes em diagonal na imagem.</p>
</div>
<div class="listingblock">
<div class="title">trocaderegioes.cpp</div>
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// Código realizado para rodar em WINDOWS sem makeFile, atente-se as intruções!
#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;

using namespace cv;
using namespace std;

int main() {
	cout &lt;&lt; "INICIANDO..." &lt;&lt; endl;

	//DEFININDO VARIAVEIS ...
	char diretorio[10000];
	Mat image, imageT;


	//RECEBENDO LOCALIZAÇÃO DA IMAGEM...
	do {
		cout &lt;&lt; "Digite a localizacao da imagem: " &lt;&lt; endl;
		cout &lt;&lt; "EX.: C:\\User\\Desktop\\&lt;nomedaimagem&gt;.&lt;png ou jpeg&gt;" &lt;&lt; endl;
		cin &gt;&gt; diretorio;

		image = imread(diretorio);

		if (!image.data) {
			cout &lt;&lt; "Imagem nao encontrada!" &lt;&lt; endl;
			cout &lt;&lt; "Verifique se a escrita esta correta." &lt;&lt; endl;
		}
	} while (!image.data);

	image.copyTo(imageT);

	int rows4q, cols4q;

	rows4q = image.rows / 2;
	cols4q = image.cols / 2;

	// DIVIDINDO OS QUADRANTES ...
	Mat q1, q2, q3, q4;
	q1 = image(Rect(0, 0, rows4q, cols4q)); // Esquerdo superior
	q2 = image(Rect(0, cols4q, rows4q, cols4q)); // Direito superior
	q3 = image(Rect(rows4q, 0, rows4q, cols4q)); // Esquerdo inferior
	q4 = image(Rect(rows4q, cols4q, rows4q, cols4q)); // Direito inferior

	cout &lt;&lt; rows4q &lt;&lt; " e " &lt;&lt; cols4q &lt;&lt; endl;

	//TROCANDO OS QUADRANTES EM DIAGONAL ...
	q1.copyTo(imageT(Rect(rows4q, cols4q, rows4q, cols4q)));
	q2.copyTo(imageT(Rect(rows4q, 0, rows4q, cols4q)));
	q3.copyTo(imageT(Rect(0, cols4q, rows4q, cols4q)));
	q4.copyTo(imageT(Rect(0, 0, rows4q, cols4q)));

	namedWindow("janelaOriginal", WINDOW_AUTOSIZE);
	imshow("janelaOriginal", image);
	namedWindow("janelaTrocado", WINDOW_AUTOSIZE);
	imshow("janelaTrocado", imageT);
	imwrite("janelaTrocado.png", imageT);
	waitKey();

	return 0;
}</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="./imagem/biel.png" alt="biel" width="256" height="256">
</div>
<div class="title">Figure 3. Biel original</div>
</div>
<div class="imageblock">
<div class="content">
<img src="./imagem/janelaTrocado.png" alt="janelaTrocado" width="256" height="256">
</div>
<div class="title">Figure 4. Biel com quadrantes trocados</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_2_serialização_via_filestore">2. Serialização via FileStore</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A serialização refere-se ao processo de converter dados em uma representação que possa ser armazenada ou transmitida,
permitindo sua recuperação posterior. No contexto da programação, a serialização é comumente usada para salvar dados em
um formato persistente, como um arquivo, para que possam ser recuperados posteriormente e usados novamente.</p>
</div>
<div class="paragraph">
<p>O ponto flutuante é um formato numérico usado para representar números reais em computadores. Ele permite representar
uma ampla gama de valores, incluindo números fracionários e números muito grandes ou muito pequenos. A serialização de
dados em ponto flutuante via FileStorage é especialmente útil quando se lida com grandes conjuntos de dados numéricos,
como matrizes ou imagens, que precisam ser armazenados e recuperados sem perda de precisão.</p>
</div>
<div class="sect2">
<h3 id="_2_1_filestore">2.1. FileStore</h3>
<div class="paragraph">
<p>O FileStorage é uma funcionalidade oferecida por algumas bibliotecas de programação, como OpenCV, que permite armazenar
dados em um arquivo com uma estrutura organizada. Essa estrutura pode incluir seções, como grupos ou tags, que ajudam a
organizar os dados serializados. Além disso, o FileStorage fornece métodos para escrever e ler dados em vários formatos,
incluindo números de ponto flutuante.</p>
</div>
<div class="sect3">
<h4 id="_2_1_1_código_resultado">2.1.1 Código &amp; Resultado.</h4>
<div class="paragraph">
<p>Crie um programa que gere uma imagem de dimensões 256x256 pixels contendo uma senóide de 4 períodos com amplitude de 127
desenhada na horizontal. Grave a imagem no formato PNG e no formato YML. Compare os arquivos gerados, extraindo uma linha
 de cada imagem gravada e comparando a diferença entre elas. Trace um gráfico da diferença calculada ao longo da linha
 correspondente extraída nas imagens. O que você observa?</p>
</div>
<div class="listingblock">
<div class="title">filestorage.cpp</div>
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

using namespace std;
using namespace cv;

int SIDE = 256;
int PERIODOS = 4;
int M_PI = 3.141516;


int main(int argc, char** argv) {
    cout &lt;&lt; "INICIANDO..." &lt;&lt; endl;

    stringstream ss_img, ss_yml;
    Mat image;

    ss_yml &lt;&lt; "senoide-" &lt;&lt; SIDE &lt;&lt; ".yml";
    image = Mat::zeros(SIDE, SIDE, CV_32FC1);

    FileStorage fs(ss_yml.str(), FileStorage::WRITE);

    for (int i = 0; i &lt; SIDE; i++) {
        for (int j = 0; j &lt; SIDE; j++) {
            image.at&lt;float&gt;(i, j) = 127 * sin(2 * M_PI * PERIODOS * j / SIDE) + 128;
        }
    }

    fs &lt;&lt; "mat" &lt;&lt; image;
    fs.release();

    normalize(image, image, 0, 255, NORM_MINMAX);
    image.convertTo(image, CV_8U);
    ss_img &lt;&lt; "senoide-" &lt;&lt; SIDE &lt;&lt; ".png";
    imwrite(ss_img.str(), image);

    cout &lt;&lt; "Matriz da imagem png... " &lt;&lt; endl;
    cout &lt;&lt; image &lt;&lt; endl;

    fs.open(ss_yml.str(), FileStorage::READ);
    fs["mat"] &gt;&gt; image;

    normalize(image, image, 0, 255, NORM_MINMAX);
    image.convertTo(image, CV_8U);

    imshow("image", image);
    waitKey();

    return 0;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_3_decomposição_de_imagens_em_planos_de_bits">3. Decomposição de imagens em planos de bits</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A decomposição de imagens em planos de bits é um processo no qual uma imagem digital é dividida em
diferentes planos, cada um representando uma determinada quantidade de bits. Essa decomposição permite
visualizar a contribuição de cada plano de bits para a formação da imagem final e pode ser útil em várias
aplicações, como processamento de imagem, compressão de dados e análise de características visuais.
No contexto da decomposição em planos de bits, consideraremos imagens em escala de cinza, onde cada pixel é
representado por um único valor de intensidade. O valor de intensidade de um pixel é geralmente representado
por um número binário, que é composto por uma sequência de bits. O número de bits utilizados para representar
a intensidade de cada pixel determina a quantidade de níveis de cinza disponíveis na imagem.</p>
</div>
<div class="sect2">
<h3 id="_3_1_esteganografia_em_imagens_digitais">3.1 Esteganografia em imagens digitais</h3>
<div class="paragraph">
<p>A esteganografia em imagens digitais é uma técnica que envolve esconder informações ou dados dentro de uma imagem
digital de forma imperceptível aos olhos humanos. É uma maneira de ocultar uma mensagem dentro de outra imagem,
conhecida como imagem de cobertura, de modo que a presença da mensagem oculta não seja facilmente detectada.
Existem várias abordagens para realizar esteganografia em imagens digitais. Uma das técnicas mais comuns é a
substituição do bit menos significativo (LSB - Least Significant Bit) dos pixels da imagem de cobertura pelos
bits da mensagem que se deseja ocultar. Como o bit menos significativo tem menos influência na representação visual
da imagem, a substituição desse bit por informações ocultas geralmente não causa alterações perceptíveis na imagem.</p>
</div>
<div class="sect3">
<h4 id="_3_1_1_código_resultado">3.1.1 Código &amp; Resultado.</h4>
<div class="paragraph">
<p>Escreva um programa que recupere a imagem codificada de uma imagem resultante de esteganografia. Lembre-se que os bits
menos significativos dos pixels da imagem fornecida deverão compor os bits mais significativos dos pixels da imagem
recuperada. O programa deve receber como parâmetros de linha de comando o nome da imagem resultante da esteganografia.</p>
</div>
<div class="listingblock">
<div class="title">decode.cpp</div>
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;

using namespace std;
using namespace cv;

int main() {
	Mat imagemCodificada, imagemPortadora, imagemEscondida;
	Vec3b valCod, valPort, valEsc;
	int nbits = 3;
	char diretorio[1000];

	// Recebendo a imagem;
	do {
		cout &lt;&lt; "Digite a localizacao da imagem codificada: " &lt;&lt; endl;
		cout &lt;&lt; "EX.: C:\\User\\Desktop\\&lt;nomedaimagem&gt;.&lt;png ou jpeg&gt;" &lt;&lt; endl;
		cin &gt;&gt; diretorio;

		imagemCodificada = imread(diretorio, IMREAD_COLOR);

		if (!imagemCodificada.data) {
			cout &lt;&lt; "Imagem nao encontrada!" &lt;&lt; endl;
			cout &lt;&lt; "Verifique o endereco digitado." &lt;&lt; endl;
		}
	} while (!imagemCodificada.data);

	// Clonando;
	imagemEscondida = imagemCodificada.clone();
	imagemPortadora = imagemCodificada.clone();

	// Realiazando a decodificação da imagem;
	for (int i = 0; i &lt; imagemCodificada.rows; i++) {
		for (int j = 0; j &lt; imagemCodificada.cols; j++) {
			valCod = imagemCodificada.at&lt;Vec3b&gt;(i, j);

			valEsc[0] = valCod[0] &lt;&lt; (8 - nbits);
			valEsc[1] = valCod[1] &lt;&lt; (8 - nbits);
			valEsc[2] = valCod[2] &lt;&lt; (8 - nbits);

			imagemEscondida.at&lt;Vec3b&gt;(i, j) = valEsc;

			valPort[0] = valCod[0] &gt;&gt; nbits &lt;&lt; nbits;
			valPort[1] = valCod[1] &gt;&gt; nbits &lt;&lt; nbits;
			valPort[2] = valCod[2] &gt;&gt; nbits &lt;&lt; nbits;

			imagemPortadora.at&lt;Vec3b&gt;(i, j) = valPort;
		}
	}

	imwrite("imagemEscondida.png", imagemEscondida);
	imwrite("imagemPortadora.png", imagemPortadora);

	return 0;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_4_preenchendo_regiões">4. Preenchendo regiões</h2>
<div class="sectionbody">
<div class="paragraph">
<p>O preenchimento de regiões em processamento digital de imagens refere-se a técnicas utilizadas para
preencher áreas vazias ou ausentes em uma imagem, com o objetivo de restaurar ou completar informações
perdidas. Essas regiões podem ser buracos, objetos removidos ou áreas danificadas na imagem original.
É importante mencionar que o resultado do preenchimento de regiões depende da natureza da área a ser
preenchida e da qualidade dos dados disponíveis na imagem original. Em algumas situações, pode ser necessário
usar técnicas mais avançadas ou até mesmo combinar várias abordagens para obter resultados satisfatórios.</p>
</div>
<div class="paragraph">
<p>Além disso, é importante ressaltar que o preenchimento de regiões em uma imagem pode introduzir informações
artificiais ou imprecisas, especialmente em áreas complexas ou com texturas irregulares. Portanto, é essencial
avaliar cuidadosamente os resultados e, se necessário, realizar ajustes manuais ou refinamentos adicionais para
obter uma restauração adequada da imagem.</p>
</div>
<div class="sect2">
<h3 id="_4_1_floodfill">4.1 FloodFill</h3>
<div class="paragraph">
<p>O algoritmo Flood Fill (preenchimento por inundação) é uma técnica utilizada em processamento digital de
imagens para preencher uma região contígua com uma cor ou padrão específico. O objetivo é identificar todos
os pixels conectados a partir de um ponto inicial e atribuir-lhes a cor desejada.</p>
</div>
<div class="paragraph">
<p>O algoritmo Flood Fill é amplamente utilizado em aplicações como edição de imagens, remoção de fundo, segmentação
de objetos e detecção de contornos. No entanto, é importante considerar que a eficiência do algoritmo pode variar
dependendo do tamanho da região a ser preenchida e da complexidade da imagem. Em casos de regiões muito grandes ou
com muitos detalhes, outras técnicas mais avançadas podem ser necessárias para obter resultados precisos e eficientes.</p>
</div>
<div class="sect3">
<h4 id="_4_1_1_código_resultado">4.1.1 Código &amp; Resultado.</h4>
<div class="paragraph">
<p>É possível verificar que caso existam mais de 255 objetos na cena, o processo de rotulação poderá ficar comprometido.
Identifique a situação em que isso ocorre e proponha uma solução para este problema. Aprimore o algoritmo de contagem
apresentado para identificar regiões com ou sem buracos internos que existam na cena. Assuma que objetos com mais de um
buraco podem existir. Inclua suporte no seu algoritmo para não contar bolhas que tocam as bordas da imagem. Não se pode
presumir, a priori, que elas tenham buracos ou não.</p>
</div>
<div class="listingblock">
<div class="title">labeling.cpp</div>
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;

using namespace cv;
using namespace std;

int main() {
	cout &lt;&lt; "INICIANDO O PROGRAMA..." &lt;&lt; endl;
	// INICIALIZANDO VÁRIAVEIS ...
	char diretorio[1000];
	Mat image;
	int cols, rows, bburacos = 0, bolhas=0;
	Point p;

	// RECEBENDO IMAGEM ...
	do {
		cout &lt;&lt; "Digite a localizacao da imagem: " &lt;&lt; endl;
		cout &lt;&lt; "EX.: C:\\User\\Desktop\\&lt;nomedaimagem&gt;.&lt;png ou jpeg&gt;" &lt;&lt; endl;
		cin &gt;&gt; diretorio;

		image = imread(diretorio, IMREAD_GRAYSCALE);

		if (!image.data) {
			cout &lt;&lt; "Imagem nao encontrada!" &lt;&lt; endl;
			cout &lt;&lt; "Verifique se a escrita esta correta." &lt;&lt; endl;
		}
	} while (!image.data);

    imshow("janelaOriginal", image);

    cols = image.cols;
    rows = image.rows;
    p.x = 0;
    p.y = 0;

    // REMOVENDO AS BOLHAS LOCALIZADAS NAS BORDAS ...
    cout &lt;&lt; "Removendo as bolhas localizadas nas bordas..." &lt;&lt; endl;

    for (int i = 0; i &lt; rows; i++) {
        for (int j = 0; j &lt; cols; j++) {
            if (image.at&lt;uchar&gt;(i, j) == 255) {
                if (i == 0 || j == 0 || i == (rows - 1) || j == (cols - 1)) {
                    p.x = j;
                    p.y = i;
                    floodFill(image, p, 0);
                }
            }
        }
    }

    p.x = 0;
    p.y = 0;
    floodFill(image, p, 200);

    for (int i = 0; i &lt; rows; i++) {
        for (int j = 0; j &lt; cols; j++) {
            if (image.at&lt;uchar&gt;(i, j) == 255) {
                p.x = j;
                p.y = i;
                bolhas++;
                floodFill(image, p, 30);
            }
        }
    }

    cout &lt;&lt; "Operacao finalizada ... " &lt;&lt; endl;
    imshow("JanelaSBolhas", image);
    imwrite("JanelaSBolhas.png", image);
    waitKey();

    // CONTANDO QUANTAS BOLHAS TEM BURACOS...
    cout &lt;&lt; "Contando quantas bolhas tem buraco..." &lt;&lt; endl;

    for (int i = 0; i &lt; rows; i++) {
        for (int j = 0; j &lt; cols; j++) {
            if (image.at&lt;uchar&gt;(i, j) == 0) {
                if (image.at&lt;uchar&gt;(i - 1, j) != 200) {
                    bburacos++;
                    p.x = j;
                    p.y = i;
                    floodFill(image, p, 200);
                }
            }
        }
    }

    cout &lt;&lt; "Operacao finalizada... " &lt;&lt; endl;
    imshow("labeling", image);
    imwrite("labeling.png", image);

    cout &lt;&lt; "total de bolhas com buracos: " &lt;&lt; bburacos &lt;&lt; endl;
    cout &lt;&lt; "total de bolhas sem buracos: " &lt;&lt; bolhas - bburacos &lt;&lt; endl;
    cout &lt;&lt; "total de bolhas: " &lt;&lt; bolhas &lt;&lt; endl;
    waitKey();

    return 0;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_5_manipulação_de_histogramas">5. Manipulação de histogramas</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A manipulação de histogramas é uma técnica utilizada em processamento digital de imagens para
alterar o contraste, brilho ou distribuição tonal de uma imagem, com base na análise e modificação do seu histograma.</p>
</div>
<div class="paragraph">
<p>O histograma de uma imagem é uma representação gráfica da distribuição de intensidades dos pixels ao longo de uma escala
de tons. Ele mostra a frequência de ocorrência de cada valor de intensidade na imagem.</p>
</div>
<div class="paragraph">
<p>A manipulação de histogramas pode ser aplicada em várias áreas, como melhoria de qualidade de imagem, correção de
iluminação, segmentação de objetos e detecção de características. É uma técnica poderosa para ajustar e realçar
informações em uma imagem com base na análise da distribuição tonal dos pixels.</p>
</div>
<div class="sect2">
<h3 id="_5_1_histograma">5.1 Histograma</h3>
<div class="paragraph">
<p>O histograma é uma ferramenta fundamental para a análise e processamento de sinais. Ele fornece informações importantes
sobre a distribuição dos dados e pode revelar características como o valor médio, variação, assimetria e presença de
picos ou ruído.</p>
</div>
<div class="paragraph">
<p>Existem técnicas e algoritmos avançados que podem ser aplicados, dependendo das necessidades específicas do
processamento de sinal. O histograma é uma ferramenta poderosa para analisar e manipular dados de sinal, ajudando
a extrair informações importantes e melhorar a qualidade e a compreensão dos sinais.</p>
</div>
<div class="sect3">
<h4 id="_5_1_1_código_resultado">5.1.1 Código &amp; Resultado</h4>
<div class="paragraph">
<p>implemente um programa equalize.cpp. Este deverá, para cada imagem capturada, realizar a equalização do histogram
antes de exibir a imagem. Teste sua implementação apontando a câmera para ambientes com iluminações variadas e
observando o efeito gerado. Assuma que as imagens processadas serão em tons de cinza.</p>
</div>
<div class="listingblock">
<div class="title">equalize.cpp</div>
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;

using namespace cv;
using namespace std;

int main(int argc, char** argv) {

    Mat imagemOriginal, imagemCinza, imagemEqualizada;
    char diretorio[1000];

    // Carregar a imagem
    cout &lt;&lt; "Digite a localizacao da imagem: " &lt;&lt; endl;
    cout &lt;&lt; "EX.: C:\\User\\Desktop\\&lt;nomedaimagem&gt;.&lt;png ou jpeg&gt;" &lt;&lt; endl;
    cin &gt;&gt; diretorio;

    imagemOriginal = imread(diretorio);

    if (imagemOriginal.empty()) {
        cout &lt;&lt; "Não foi possível carregar a imagem" &lt;&lt; endl;
        return -1;
    }

    // Converter para escala de cinza
    cvtColor(imagemOriginal, imagemCinza, COLOR_BGR2GRAY);

    // Equalizar o histograma
    equalizeHist(imagemCinza, imagemEqualizada);

    imshow("Imagem em Escala de Cinza", imagemCinza);
    imwrite("ImagememEscaladeCinza.png", imagemCinza);
    imshow("Imagem Equalizada", imagemEqualizada);
    imwrite("ImagemEqualizada.png", imagemEqualizada);
    waitKey(0);

    return 0;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_6_filtragem_no_domínio_espacial_i">6. Filtragem no domínio espacial I.</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A filtragem no domínio espacial refere-se à aplicação de um filtro direto aos pixels de uma
imagem, no próprio domínio espacial da imagem. Nesse tipo de filtragem, cada pixel é processado
individualmente, sem levar em consideração a estrutura ou as características globais da imagem.</p>
</div>
<div class="paragraph">
<p>Existem vários tipos de filtros que podem ser aplicados no domínio espacial, e eles têm diferentes efeitos na imagem.
Alguns exemplos comuns são: filtro de suavização, filtro de realce e filtro de nitidez. Esses são apenas alguns exemplos
de filtros que podem ser aplicados no domínio espacial. A escolha do filtro depende das características específicas da
imagem e do objetivo desejado. A filtragem no domínio espacial é uma técnica amplamente utilizada no processamento de
imagens e possui uma variedade de aplicações, incluindo restauração de imagens, detecção de bordas e redução de ruído.</p>
</div>
<div class="sect2">
<h3 id="_6_1_laplaciano_do_gaussiano">6.1 Laplaciano do Gaussiano.</h3>
<div class="paragraph">
<p>O Laplaciano do Gaussiano (LoG) é um filtro espacial que combina as propriedades do filtro gaussiano e do operador
laplaciano para detecção de bordas e características pontuais em uma imagem. A combinação do filtro gaussiano e do
operador laplaciano no Laplaciano do Gaussiano permite que o filtro seja menos sensível ao ruído e mais eficaz na
detecção de bordas do que o operador laplaciano aplicado diretamente à imagem original.</p>
</div>
<div class="paragraph">
<p>O Laplaciano do Gaussiano é uma técnica amplamente utilizada no processamento de imagens, especialmente em aplicações
que envolvem a detecção de bordas e características pontuais.</p>
</div>
<div class="sect3">
<h4 id="_6_1_1_código_resultado">6.1.1 Código &amp; Resultado</h4>
<div class="paragraph">
<p>Implemente um programa laplgauss.cpp. O programa deverá acrescentar mais uma funcionalidade ao exemplo fornecido,
permitindo que seja calculado o laplaciano do gaussiano das imagens capturadas. Compare o resultado desse filtro
com a simples aplicação do filtro laplaciano.</p>
</div>
<div class="listingblock">
<div class="title">laplgauss.cpp</div>
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;

using namespace std;
using namespace cv;

void printmask(Mat &amp;m) {
	for (int i = 0; i &lt; m.size().height; i++) {
		for (int j = 0; j &lt; m.size().width; j++) {
			cout &lt;&lt; m.at&lt;float&gt;(i, j) &lt;&lt; ",";
		}
		cout &lt;&lt; "\n";
	}
}

int main() {
	float media[] = { 0.1111, 0.1111, 0.1111, 0.1111, 0.1111,
				   0.1111, 0.1111, 0.1111, 0.1111 };
	float gauss[] = { 0.0625, 0.125,  0.0625, 0.125, 0.25,
					 0.125,  0.0625, 0.125,  0.0625 };
	float horizontal[] = { -1, 0, 1, -2, 0, 2, -1, 0, 1 };
	float vertical[] = { -1, -2, -1, 0, 0, 0, 1, 2, 1 };
	float laplacian[] = { 0, -1, 0, -1, 4, -1, 0, -1, 0 };
	float boost[] = { 0, -1, 0, -1, 5.2, -1, 0, -1, 0 };
	float laplacianOfGaussian[] = { 0,0,1,0,0,
									0,1,2,1,0,
									1,2,-16,2,1,
									0,1,2,1,0,
									0,0,1,0,0 };
	char diretorio[1000], key;
	Mat imagem, framegray, frame32f, frameFiltered,
		mask(3, 3, CV_32F), result;
	int absolut;

	do {
		cout &lt;&lt; "Digite a localizacao da imagem: " &lt;&lt; endl;
		cout &lt;&lt; "EX.: C:\\User\\Desktop\\&lt;nomedaimagem&gt;.&lt;png ou jpeg&gt;" &lt;&lt; endl;
		cin &gt;&gt; diretorio;

		imagem = imread(diretorio);

		if (!imagem.data) {
			cout &lt;&lt; "Imagem nao encontrada!" &lt;&lt; endl;
			cout &lt;&lt; "Verifique se a escrita esta correta." &lt;&lt; endl;
		}
	} while (!imagem.data);

	cvtColor(imagem, framegray, COLOR_BGR2GRAY);
	imshow("original", framegray);

	framegray.convertTo(frame32f, CV_32F);

	mask = Mat(3, 3, CV_32F, media);
	absolut = 1;

	for (;;) {
		filter2D(frame32f, frameFiltered, frame32f.depth(), mask, Point(1, 1), 0);

		if (absolut) {
			Mat frameAbs;
			absdiff(frameFiltered, Scalar(0), frameAbs);
			frameFiltered = frameAbs;
		}

		frameFiltered.convertTo(result, CV_8U);
		imshow("filtroespacial", result);

		key = (char)waitKey(0);
		if (key == 27) break;
		switch (key) {
		case 'a':
			absolut = !absolut;
			break;
		case 'm':
			mask = Mat(3, 3, CV_32F, media);
			printmask(mask);
			break;
		case 'g':
			mask = cv::Mat(3, 3, CV_32F, gauss);
			printmask(mask);
			break;
		case 'l':
			mask = cv::Mat(3, 3, CV_32F, laplacian);
			printmask(mask);
			imwrite("laplacian.png", result);
			break;
		case 'o':
			mask = cv::Mat(5, 5, CV_32F, laplacianOfGaussian);
			printmask(mask);
			imwrite("laplacianofgaussian.png", result);
			break;
		default:
			break;
		}
	}

	return 0;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_6_2_tiltshift">6.2 TiltShift</h3>
<div class="paragraph">
<p>O efeito Tilt-Shift é uma técnica popular de pós-processamento de imagens que cria a ilusão de
miniaturização em uma foto, fazendo com que a cena pareça uma maquete ou um modelo em escala reduzida.
O nome "Tilt-Shift" refere-se aos movimentos de inclinação (tilt) e deslocamento (shift) que são usados
em câmeras de grande formato para controlar a profundidade de campo e a perspectiva.</p>
</div>
<div class="paragraph">
<p>Na fotografia tradicional, a miniaturização é alcançada através do uso de uma lente de deslocamento (shift lens)
que permite controlar a área de foco seletivamente e criar uma profundidade de campo extremamente rasa.</p>
</div>
<div class="sect3">
<h4 id="_6_2_1_código_resultado">6.2.1 Código &amp; Resultado</h4>
<div class="listingblock">
<div class="title">tiltshift.cpp</div>
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;

using namespace cv;
using namespace std;

double alfa;
int center_slider = 0;
int center_slider_max = 100;

int alfa_slider = 0;
int alfa_slider_max = 100;

int top_slider = 0;
int top_slider_max = 100;

float media[] = { 1,1,1,1,1,1,1,1,1 };

Mat imagemOriginal, imagemEditada, blended;
Mat imageTop;

char TrackbarName[50];

void on_trackbar_blend(int, void*) {
    alfa = (double)alfa_slider / alfa_slider_max;
    addWeighted(imagemOriginal, alfa, imageTop, 1 - alfa, 0.0, blended);
    imshow("addweighted", blended);
}

void on_trackbar_change(int, void*) {
    imagemEditada.copyTo(imageTop);
    Size size = imagemEditada.size();
    int width = size.width;
    int height = size.height;
    int limit = top_slider * width / 100;
    int base = center_slider * width / 100;
    if (limit &gt; 0) {
        if (base &gt;= 0 &amp;&amp; base &lt;= height - limit) {
            Mat tmp = imagemOriginal(Rect(0, base, width, limit));
            tmp.copyTo(imageTop(Rect(0, base, width, limit)));
        }
        else {
            Mat tmp = imagemOriginal(Rect(0, height - limit, width, limit));
            tmp.copyTo(imageTop(Rect(0, height - limit, width, limit)));
        }
    }
    on_trackbar_blend(alfa_slider, 0);
}

int main() {
    char diretorio[1000];

    do {
        cout &lt;&lt; "Digite o endereço da imagem" &lt;&lt; endl;
        cout &lt;&lt; "C:\\Users\\User\\Desktop\...\\&lt;nomedaimagem&gt;.&lt;extencao&gt;" &lt;&lt; endl;
        cin &gt;&gt; diretorio;

        imagemOriginal = imread(diretorio);

        if (!imagemOriginal.data) {
            cout &lt;&lt; "Imagem nao encontrada!" &lt;&lt; endl;
            cout &lt;&lt; "Verifique se a escrita esta correta." &lt;&lt; endl;
        }
    } while (!imagemOriginal.data);

    imagemEditada = imagemOriginal.clone();
    Mat aux, mask, mask1;

    mask = Mat(3, 3, CV_32F, media);
    scaleAdd(mask, 1 / 9.0, Mat::zeros(3, 3, CV_32F), mask1);
    swap(mask, mask1);
    imagemEditada.convertTo(aux, CV_32F);

    for (int i = 0; i &lt; 10; i++) {
        filter2D(aux, aux, aux.depth(), mask, Point(1, 1), 0);
        aux = abs(aux);
        aux.convertTo(imagemEditada, CV_8UC3);
        imagemOriginal.copyTo(imageTop);
    }

    namedWindow("addweighted", 1);

    sprintf_s(TrackbarName, "Decaimento");
    createTrackbar(TrackbarName, "addweighted", &amp;alfa_slider, alfa_slider_max, on_trackbar_blend);
    on_trackbar_blend(alfa_slider, 0);

    sprintf_s(TrackbarName, "Altura ");
    createTrackbar(TrackbarName, "addweighted", &amp;top_slider, top_slider_max, on_trackbar_change);
    on_trackbar_change(top_slider, 0);

    sprintf_s(TrackbarName, "Posição");
    createTrackbar(TrackbarName, "addweighted", &amp;center_slider, center_slider_max, on_trackbar_change);

    imwrite("imagemEditada.png", imagemEditada);

    waitKey(0);
    return 0;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_7_a_tranformada_discreta_de_fourier">7. A Tranformada Discreta de Fourier</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_7_1">7.1</h3>
<div class="sect3">
<h4 id="_7_1_1_código_resultado">7.1.1 Código &amp; Resultado</h4>

</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_8_filtragem_no_domínio_da_frequência">8. Filtragem no Domínio da Frequência</h2>
<div class="sectionbody">
<div class="paragraph">
<p>O processamento de imagens no domínio da frequência refere-se às técnicas que envolvem a manipulação das
informações de frequência de uma imagem. Isso é feito usando a Transformada de Fourier, especificamente a
Transformada Discreta de Fourier (DFT) ou sua variante mais comum, a Transformada Rápida de Fourier (FFT).</p>
</div>
<div class="paragraph">
<p>O processamento de imagens no domínio da frequência é usado em uma variedade de aplicações, incluindo filtragem
de imagens, compressão de imagens, análise de texturas, detecção de bordas e restauração de imagens. Ele permite
manipular seletivamente as características de frequência da imagem, explorando as informações de frequência para
obter resultados desejados.</p>
</div>
<div class="sect2">
<h3 id="_8_1_filtro_homomórfico">8.1 Filtro Homomórfico</h3>
<div class="paragraph">
<p>O filtro homomórfico é uma técnica de processamento de imagens que combina as propriedades de filtragem espacial
e frequencial para melhorar a qualidade de imagens que foram afetadas por iluminação não uniforme ou variações
de contraste. Ele é amplamente utilizado em aplicações de processamento de imagens em áreas como visão computacional,
análise de imagens e processamento de imagens médicas.</p>
</div>
<div class="paragraph">
<p>A ideia básica do filtro homomórfico é aplicar uma transformação logarítmica à imagem original para mapear os valores
de intensidade da imagem para uma escala mais ampla. Isso ajuda a lidar com as variações de iluminação não uniforme. A
transformação logarítmica é seguida pela aplicação de uma Transformada de Fourier para obter a representação da imagem
no domínio da frequência. Nesse ponto, é possível realizar uma filtragem no domínio da frequência para separar as
componentes de baixa e alta frequência.</p>
</div>
<div class="paragraph">
<p>O filtro homomórfico utiliza um filtro passa-alta (filtro de nitidez) para realçar os detalhes e uma função de ganho
(filtro de correção) para controlar as variações de iluminação. A função de ganho é projetada para atenuar as baixas
frequências, que correspondem aos componentes de iluminação, e amplificar as altas frequências, que correspondem aos
detalhes e texturas. Depois da filtragem no domínio da frequência, é aplicada a transformada inversa de Fourier para
retornar a imagem ao domínio espacial. A imagem resultante é uma versão melhorada da imagem original, com a correção
das variações de iluminação e realce dos detalhes.</p>
</div>
<div class="sect3">
<h4 id="_8_1_1_código_resultado">8.1.1 Código &amp; Resultado</h4>
<div class="paragraph">
<p>Implemente o filtro homomórfico para melhorar imagens com iluminação irregular. Crie uma cena mal iluminada
e ajuste os parâmetros do filtro homomórfico para corrigir a iluminação da melhor forma possível. Assuma que
a imagem fornecida é em tons de cinza.</p>
</div>
<div class="listingblock">
<div class="title">homomorfico.cpp</div>
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;
#include &lt;opencv2/imgproc/imgproc.hpp&gt;


using namespace cv;
using namespace std;

void reciveVal(int** x, int** x2) {

	*x = new int;
	*x2 = new int;
}

void setVal(int* gl, int* gh, int* c, int* d0) {

	*gl = 10;
	*gh = 20;
	*c  = 60;
	*d0 = 70;
}

//	Funcoes para direcionar ponteiros
void on_gammaL (int, void*){}
void on_gammaH (int, void*){}
void on_c      (int, void*){}
void on_d0     (int, void*){}


void deslDFT(Mat&amp; image) {

	Mat temp, A, B, C, D;

	image = image(Rect(0, 0, image.cols &amp; -2, image.rows &amp; -2));
	int cols = image.cols / 2;
	int rows = image.rows / 2;

	// trocar regiões
	A = image(Rect(0, 0, cols, rows));
	B = image(Rect(cols, 0, cols, rows));
	C = image(Rect(0, rows, cols, rows));
	D = image(Rect(cols, rows, cols, rows));

	A.copyTo(temp);
	D.copyTo(A);
	temp.copyTo(D);

	B.copyTo(temp);
	C.copyTo(B);
	temp.copyTo(C);
}

void filterHomomo(Mat temp, int* gl, int* gh, int* c,
						int* d0, int dft_M, int dft_N) {

	float gl_temp, gh_temp, c_temp, d0_temp, aux, aux2;
	gl_temp = *gl / 10;
	gh_temp = *gh / 10;
	c_temp  = *c / 10;
	d0_temp = *d0 / 10;

	for (int i = 0; i &lt; temp.rows; i++) {
		for (int j = 0; j &lt; temp.cols; j++) {

			aux  = (i - dft_M / 2) * (i - dft_M / 2)
				 + (j - dft_N / 2) * (j - dft_N / 2);
			aux2 = (1.0 - (float)exp(-(c_temp * aux / (d0_temp * d0_temp))));
			temp.at&lt;float&gt;(i, j) = (gh_temp - gl_temp)
				* aux2 + gl_temp;
		}
	}
}

int main() {

	Mat imaginaryInput, imageComplex, multsp,
		padded, filter, mag;
	Mat image, grayimage, temp;
	Mat_&lt;float&gt; realInput, zeros;
	vector&lt;Mat&gt; planos;
	int* gl, * gh, * c, * d0;
	int dft_M, dft_N;
	char diretorio[1000];

	cout &lt;&lt; "Digite o endereço da imagem" &lt;&lt; endl;
	cin &gt;&gt; diretorio;
	image = imread(diretorio, IMREAD_GRAYSCALE);

	reciveVal(&amp;gl, &amp;gh);
	reciveVal(&amp;c , &amp;d0);
	setVal(gl, gh, c, d0);

	imshow("Original", image);

	dft_M = getOptimalDFTSize(image.rows);
	dft_N = getOptimalDFTSize(image.cols);

	copyMakeBorder(image, padded, 0, dft_M - image.rows,
					0, dft_N - image.cols, BORDER_CONSTANT,
					Scalar::all(0));

	zeros = Mat_&lt;float&gt;::zeros(padded.size());
	imageComplex = Mat(padded.size(), CV_32FC2, Scalar(0));
	filter = imageComplex.clone();
	temp = Mat(dft_M, dft_N, CV_32F);
	namedWindow("Filtro", 1);

	createTrackbar("c", "Filtro", c, 100, on_c);
	createTrackbar("d0 ", "Filtro", d0, 100, on_d0);
	createTrackbar("gammaH", "Filtro", gh, 100, on_gammaH);
	createTrackbar("gammaL", "Filtro", gl, 100, on_gammaL);

	while (1) {

		on_c(*c, 0);
		on_d0(*d0, 0);
		on_gammaH(*gh, 0);
		on_gammaL(*gl, 0);

		copyMakeBorder(image, padded, 0, dft_M - image.rows,
			0, dft_N - image.cols, BORDER_CONSTANT,
			Scalar::all(0));

		planos.clear();
		realInput = Mat_&lt;float&gt;(padded);
		planos.push_back(realInput);
		planos.push_back(zeros);

		merge(planos, imageComplex);
		dft(imageComplex, imageComplex);
		deslDFT(imageComplex);
		filterHomomo(temp, gl, gh, c, d0, dft_M, dft_N);

		Mat comps[] = { temp, temp };
		merge(comps, 2, filter);
		mulSpectrums(imageComplex, filter, imageComplex, 0);

		deslDFT(imageComplex);
		idft(imageComplex, imageComplex);
		planos.clear();
		split(imageComplex, planos);
		normalize(planos[0], planos[0], 0, 1, NORM_MINMAX);
		imshow("Filtro Homomo", planos[0]);

		if (waitKey(10) == 27) break;

	}
	return 0;

}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_9_detecção_de_bordas_com_o_algoritmo_de_canny">9. Detecção de bordas com o algoritmo de Canny</h2>
<div class="sectionbody">
<div class="paragraph">
<p>O algoritmo de Canny é uma técnica clássica e amplamente utilizada para detecção de bordas em imagens.
Ele foi desenvolvido por John F. Canny em 1986 e é conhecido por sua precisão e robustez na detecção de bordas,
minimizando a resposta a ruídos e fornecendo bordas bem definidas.</p>
</div>
<div class="paragraph">
<p>O algoritmo de Canny envolve os seguintes passos principais: redução do ruído, cálculo do gradiente, supressão não
máxima, limiarização por histerese e rastreamento de bordas. O resultado final do algoritmo de Canny é uma imagem binária
com as bordas claramente destacadas. O algoritmo oferece uma detecção precisa e robusta de bordas, com capacidade de
lidar com ruídos e fornecer bordas bem definidas.</p>
</div>
<div class="sect2">
<h3 id="_9_1_canny_pontilhismo">9.1 Canny &amp; Pontilhismo</h3>
<div class="paragraph">
<p>O algoritmo de Canny e o pontilhismo são conceitos distintos, mas é possível combinar essas técnicas para criar
um efeito artístico interessante.</p>
</div>
<div class="paragraph">
<p>O algoritmo de Canny, como explicado anteriormente, é usado para a detecção de bordas em imagens. Ele identifica
as transições abruptas de intensidade na imagem e destaca essas áreas como bordas. O resultado é uma imagem binária
com bordas bem definidas. Por outro lado, o pontilhismo é uma técnica artística em que a imagem é criada a partir
de pequenos pontos ou pontos de cor. Esses pontos, quando vistos em conjunto, formam a imagem final. O pontilhismo
é inspirado na forma como o olho humano percebe a mistura de cores quando vários pontos são visualizados de certa
distância.</p>
</div>
<div class="paragraph">
<p>A combinação do algoritmo de Canny e o pontilhismo pode ser alcançada aplicando-se a técnica do pontilhismo nas
bordas detectadas pelo algoritmo de Canny. Em vez de usar pontos uniformes para representar a imagem inteira, os
pontos são colocados apenas nas bordas encontradas. Essa abordagem pode resultar em uma representação artística da
imagem, onde as bordas são enfatizadas pelos pontos, enquanto outras áreas da imagem podem permanecer mais suaves
ou com um estilo diferente.</p>
</div>
<div class="sect3">
<h4 id="_9_1_1_código_resultado">9.1.1 Código &amp; Resultado</h4>
<div class="paragraph">
<p>Implemente um programa cannypoints.cpp. A idéia é usar as bordas produzidas pelo algoritmo de Canny para melhorar a
qualidade da imagem pontilhista gerada. A forma como a informação de borda será usada é livre.</p>
</div>
<div class="listingblock">
<div class="title">cannypoints.cpp</div>
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;
#include &lt;fstream&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;ctime&gt;
#include &lt;cstdlib&gt;

using namespace std;
using namespace cv;

vector&lt;int&gt; showCenter(vector&lt;int&gt; x, int step) {

    for (uint i = 0; i &lt; x.size(); i++) {
        x[i] = x[i] * step + step / 2;
    }
    return x;
}

void funcCircle(Mat image, Mat imageArt, Vec3b color, int r, int x, int y) {

    color = image.at&lt;Vec3b&gt;(x, y);
    circle(imageArt, Point(y, x), r, CV_RGB(color[2], color[1], color[0]), -1, LINE_AA);
}

int main() {
    vector&lt;int&gt; cols, rows;
    Mat imagem, fps, points, gray, ofusc, borders;
    int x, y, fator = 60, passo = 5, jitter = 3, raio = 3;
    Vec3b cor;
    char diretorio[1000];

    cout &lt;&lt; "Digite o endereço da imagem: " &lt;&lt; endl;
    cin &gt;&gt; diretorio;

    imagem = imread(diretorio);
    Mat imagemArte(imagem.rows, imagem.cols, imagem.type());
    srand(time(0));

    if (!imagem.data) {
        cout &lt;&lt; "nao abriu" &lt;&lt; endl;
        exit(0);
    }

    rows.resize(imagem.rows / passo);
    cols.resize(imagem.cols / passo);
    iota(rows.begin(), rows.end(), 0);
    iota(cols.begin(), cols.end(), 0);
    rows = showCenter(rows, passo);
    cols = showCenter(cols, passo);

    random_shuffle(rows.begin(), rows.end());
    for (auto i : rows) {

        random_shuffle(cols.begin(), cols.end());
        for (auto j : cols) {

            x = i + rand() % (2 * jitter) - jitter + 1;
            y = j + rand() % (2 * jitter) - jitter + 1;
            funcCircle(imagem, imagemArte, cor, raio, x, y);
        }
    }
    imwrite("points.jpg", imagemArte);

    cvtColor(imagemArte, gray, COLOR_BGR2GRAY);
    GaussianBlur(gray, ofusc, Size(5, 5), 25, 25);
    Canny(ofusc, borders, fator, 3 * fator);
    imwrite("canny.jpg", borders);

    for (int i = 0; i &lt; imagemArte.rows; i++) {
        for (int j = 0; j &lt; imagemArte.cols; j++) {
            if (borders.at&lt;uchar&gt;(i, j) == 255) {
                funcCircle(imagemArte, imagemArte, cor, 2, i, j);
            }
        }
    }

    imwrite("arte.jpg", imagemArte);
    imshow("arte", imagemArte);
    waitKey();
    return 0;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_10_quantização_vetorial_com_k_means">10. Quantização vetorial com k-means</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A quantização vetorial com o algoritmo k-means é uma técnica usada para reduzir a quantidade de cores em uma imagem.
Ela agrupa os pixels da imagem em um número específico de clusters com base em sua similaridade de cor e, em seguida,
substitui os valores de cor dos pixels pelos valores médios dos clusters aos quais pertencem.</p>
</div>
<div class="paragraph">
<p>O algoritmo k-means é um algoritmo de aprendizado não supervisionado que visa particionar um conjunto de dados em k
grupos distintos. No contexto da quantização vetorial de imagens, os pixels são tratados como pontos de dados no
espaço de cores e o objetivo é agrupá-los em k clusters representativos.</p>
</div>
<div class="paragraph">
<p>A quantização vetorial com k-means é eficaz para reduzir o número de cores em uma imagem, o que pode ser útil para
economizar espaço de armazenamento ou simplificar a análise de imagens. No entanto, é importante lembrar que a redução
de cores pode resultar em perda de detalhes e qualidade visual, dependendo da aplicação e da quantidade de cores
escolhida. Portanto, é necessário encontrar um equilíbrio entre a redução de cores e a preservação da qualidade visual
desejada.</p>
</div>
<div class="sect2">
<h3 id="_10_1_k_means">10.1 K-means</h3>
<div class="paragraph">
<p>É importante mencionar que o resultado do k-means depende da escolha inicial dos centroides. Como o algoritmo pode
convergir para mínimos locais, diferentes inicializações podem resultar em diferentes soluções. Portanto, para obter
uma solução mais robusta, geralmente é necessário executar o algoritmo várias vezes com diferentes inicializações e
escolher a melhor solução com base em algum critério, como a soma das distâncias dos pontos aos centroides.</p>
</div>
<div class="sect3">
<h4 id="_10_1_1_código_resultado">10.1.1 Código &amp; Resultado</h4>
<div class="paragraph">
<p>Implemente um programa exemplo onde a execução do código se dê usando o parâmetro nRodadas=1 e inciar os centros
de forma aleatória usando o parâmetro KMEANS_RANDOM_CENTERS ao invés de KMEANS_PP_CENTERS. Realize 10 rodadas
diferentes do algoritmo e compare as imagens produzidas.</p>
</div>
<div class="listingblock">
<div class="title">kmeansrandom.cpp</div>
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;opencv2/opencv.hpp&gt;
#include &lt;cstdlib&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

using namespace std;
using namespace cv;

int main() {

	int nCluster = 6, nRodadas = 1, cont = 1;
	Mat rotulos, centros, imagem;
	char diretorio[1000];

	cout &lt;&lt; "Digite o endereço da imagem: " &lt;&lt; endl;
	cin &gt;&gt; diretorio;

	imagem = imread(diretorio, IMREAD_COLOR);
	Mat samples(imagem.rows * imagem.cols, 3, CV_32F);

	while (cont &lt;= 10) {
		for (int y = 0; y &lt; imagem.rows; y++) {
			for (int x = 0; x &lt; imagem.cols; x++) {
				for (int z = 0; z &lt; 3; z++) {
					samples.at&lt;float&gt;(y + x * imagem.rows, z) = imagem.at&lt;Vec3b&gt;(y, x)[z];
				}
			}
		}

		kmeans(samples,	nCluster, rotulos,
			TermCriteria(TermCriteria::MAX_ITER | TermCriteria::EPS, 10000, 0.0001),
			nRodadas, KMEANS_RANDOM_CENTERS,centros);

		Mat rotulada(imagem.size(), imagem.type());
		for (int y = 0; y &lt; imagem.rows; y++) {
			for (int x = 0; x &lt; imagem.cols; x++) {
				int indice = rotulos.at&lt;int&gt;(y + x * imagem.rows, 0);
				rotulada.at&lt;cv::Vec3b&gt;(y, x)[0] = (uchar)centros.at&lt;float&gt;(indice, 0);
				rotulada.at&lt;cv::Vec3b&gt;(y, x)[1] = (uchar)centros.at&lt;float&gt;(indice, 1);
				rotulada.at&lt;cv::Vec3b&gt;(y, x)[2] = (uchar)centros.at&lt;float&gt;(indice, 2);
			}
		}

		stringstream ss;
		ss &lt;&lt; "saida" &lt;&lt; cont &lt;&lt; ".jpg";
		string s = ss.str();
		cont++;
		imshow("clustered image", rotulada);
		imwrite(s, rotulada);
		waitKey(1);

	}

	return 0;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2023-07-17 18:26:20 -0300
</div>
</div>
</body>
</html>